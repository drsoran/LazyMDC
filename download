#!venv/bin/python

import asyncio
import io
import json
import os
import re
import sys
import urllib

from pyppeteer import launch
from PIL import Image
from zipfile import ZipFile

RE_ARGS = {
    'id': re.compile(r'^[0-9a-zA-Z-]+$'),
    'key': re.compile(r'^[0-9a-zA-Z-]+$'),
    'template': re.compile(r'^[a-z]+$', re.IGNORECASE),
    'output': re.compile(r'^(png|pdf)$'),
}

PNG_WIDTH = 800
PNG_HEIGHT = 1200


async def get_image(url):

    browser = await launch({
        'headless': True,
        'executablePath': '/usr/share/chromium/588429/chrome',
        'userDataDir': '/tmp/httpd/pyppeteer',
    })

    page = await browser.newPage()

    await page.goto(url)
    await page.waitForSelector("#page_count")

    page_count = await page.evaluate('''
    () => {
        return parseInt(document.getElementById("page_count").textContent);
    }
    ''')

    await page.setViewport({
        'width': PNG_WIDTH,
        'height': PNG_HEIGHT*page_count})

    screenshot = await page.screenshot({'type': 'png'})
    await browser.close()

    return (page_count, screenshot)


async def get_pdf(url):
    browser = await launch({
        'headless': True,
        'executablePath': '/usr/share/chromium/588429/chrome',
        'userDataDir': '/tmp/httpd/pyppeteer',
    })

    page = await browser.newPage()

    await page.goto(url)
    await page.waitForSelector("#page_count")

    page_count = await page.evaluate('''
    () => {
        return parseInt(document.getElementById("page_count").textContent);
    }
    ''')

    await page.setViewport({
        'width': 800,
        'height': 1200*page_count
    })

    pdf = await page.pdf({
        'width': '800px',
        'height': '1200px',
        'margin': {
            'top': 0,
            'bottom': 0,
            'left': 0,
            'right': 0
        },
        'printBackground': True,
    })

    await browser.close()

    return pdf


def main():

    qs = urllib.parse.parse_qs(os.environ.get('QUERY_STRING', ""))

    params = {}
    for key, re in RE_ARGS.items():
        if key not in qs or not re.match(qs[key][0]):
            print("Content-Type: text/html")
            print("Status: 400 Bad Request\n")
            sys.exit(0)
        else:
            params[key] = qs[key][0]

    url = (
        '{scheme}://{host}/{root}'
        '/templates/{template}/template.htm?kb={key}').format(
        scheme=os.environ.get('REQUEST_SCHEME'),
        host=os.environ.get('HTTP_HOST'),
        root=os.path.dirname(os.environ.get('SCRIPT_NAME')),
        template=params['template'],
        key=params['key'])

    if params['output'] == "pdf":
        data = asyncio.get_event_loop().run_until_complete(get_pdf(url))

        print ("Content-Disposition: attachment; "
               "filename=\"MDC-%s.pdf\"" % params['id'])
        print("Content-Type: application/pdf\n")
        sys.stdout.flush()
        sys.stdout.buffer.write(data)
        return

    if params['output'].startswith("png"):

        pages, data = asyncio.get_event_loop().run_until_complete(
            get_image(url))

        if pages == 1:
            print ("Content-Disposition: attachment; "
                   "filename=\"0000-%s-0001.png\"" % params['id'])
            print("Content-Type: image/png\n")
            sys.stdout.flush()
            sys.stdout.buffer.write(data)
            return

        # Load into PIL
        im1 = Image.open(io.BytesIO(data))

        # Zip up each page
        zipfd = io.BytesIO()
        zipf = ZipFile(zipfd, 'w')

        # Crop out pages
        for x in range(pages):
            cr = im1.crop((0, PNG_HEIGHT * x, PNG_WIDTH, PNG_HEIGHT * (x+1)))
            f = io.BytesIO()
            cr.save(f, "PNG")
            f.seek(0)
            zipf.writestr('0000-%s-%03d.png' % (params['id'], x+1), f.read())

        zipf.close()
        zipfd.seek(0)

        print ("Content-Disposition: attachment; "
               "filename=\"MDC-%s.zip\"" % params['id'])
        print ("Content-Type: application/zip\n")
        sys.stdout.flush()
        sys.stdout.buffer.write(zipfd.read())
        return

    print("Content-Type: text/plain\n")
    print("UNKNOWN")


if __name__ == "__main__":
    main()
